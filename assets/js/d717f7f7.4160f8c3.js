"use strict";(self.webpackChunkctdlct_177_2=self.webpackChunkctdlct_177_2||[]).push([[269],{3905:(t,e,n)=>{n.d(e,{Zo:()=>u,kt:()=>s});var r=n(7294);function o(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function i(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,r)}return n}function a(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?i(Object(n),!0).forEach((function(e){o(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function p(t,e){if(null==t)return{};var n,r,o=function(t,e){if(null==t)return{};var n,r,o={},i=Object.keys(t);for(r=0;r<i.length;r++)n=i[r],e.indexOf(n)>=0||(o[n]=t[n]);return o}(t,e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(t);for(r=0;r<i.length;r++)n=i[r],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(o[n]=t[n])}return o}var c=r.createContext({}),l=function(t){var e=r.useContext(c),n=e;return t&&(n="function"==typeof t?t(e):a(a({},e),t)),n},u=function(t){var e=l(t.components);return r.createElement(c.Provider,{value:e},t.children)},d={inlineCode:"code",wrapper:function(t){var e=t.children;return r.createElement(r.Fragment,{},e)}},h=r.forwardRef((function(t,e){var n=t.components,o=t.mdxType,i=t.originalType,c=t.parentName,u=p(t,["components","mdxType","originalType","parentName"]),h=l(n),s=o,f=h["".concat(c,".").concat(s)]||h[s]||d[s]||i;return n?r.createElement(f,a(a({ref:e},u),{},{components:n})):r.createElement(f,a({ref:e},u))}));function s(t,e){var n=arguments,o=e&&e.mdxType;if("string"==typeof t||o){var i=n.length,a=new Array(i);a[0]=h;var p={};for(var c in e)hasOwnProperty.call(e,c)&&(p[c]=e[c]);p.originalType=t,p.mdxType="string"==typeof t?t:o,a[1]=p;for(var l=2;l<i;l++)a[l]=n[l];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},3524:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>i,metadata:()=>p,toc:()=>l});var r=n(7462),o=(n(7294),n(3905));const i={sidebar_position:2},a="M\u1ed9t s\u1ed1 ph\xe9p to\xe1n",p={unversionedId:"adts-binary-search-tree/apply",id:"adts-binary-search-tree/apply",title:"M\u1ed9t s\u1ed1 ph\xe9p to\xe1n",description:"deleteNode",source:"@site/docs/adts-binary-search-tree/apply.md",sourceDirName:"adts-binary-search-tree",slug:"/adts-binary-search-tree/apply",permalink:"/docs/adts-binary-search-tree/apply",draft:!1,editUrl:"https://github.com/thangved/datastructure/docs/adts-binary-search-tree/apply.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"T\u1ed5ng quan",permalink:"/docs/adts-binary-search-tree/intro"},next:{title:"Gi\u1edbi thi\u1ec7u v\u1ec1 git",permalink:"/docs/git-tutorial/intro"}},c={},l=[{value:"deleteNode",id:"deletenode",level:2},{value:"rightSibling",id:"rightsibling",level:2},{value:"printPath",id:"printpath",level:2},{value:"getParent",id:"getparent",level:2},{value:"insertNode",id:"insertnode",level:2},{value:"searchNode",id:"searchnode",level:2},{value:"hNode",id:"hnode",level:2},{value:"getPrevious",id:"getprevious",level:2}],u={toc:l};function d(t){let{components:e,...n}=t;return(0,o.kt)("wrapper",(0,r.Z)({},u,n,{components:e,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"m\u1ed9t-s\u1ed1-ph\xe9p-to\xe1n"},"M\u1ed9t s\u1ed1 ph\xe9p to\xe1n"),(0,o.kt)("h2",{id:"deletenode"},"deleteNode"),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"X\xf3a m\u1ed9t n\xfat c\xf3 kh\xf3a l\xe0 x trong c\xe2y t\xecm ki\u1ebfm nh\u1ecb ph\xe2n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c"},"int deleteMax(Tree *pT)\n{\n    if ((*pT)->Right == NULL)\n    {\n        int key = (*pT)->Key;\n        *pT = (*pT)->Left;\n        return key;\n    }\n    return deleteMax(&((*pT)->Right));\n}\n\nvoid deleteNode(int x, Tree *pT)\n{\n    if (*pT == NULL)\n        return;\n    if ((*pT)->Key != x)\n    {\n        if ((*pT)->Key > x)\n            return deleteNode(x, &((*pT)->Left));\n        return deleteNode(x, &((*pT)->Right));\n    }\n    if ((*pT)->Left == NULL || (*pT)->Right == NULL)\n    {\n        *pT = NULL;\n        return;\n    }\n\n    if ((*pT)->Left == NULL)\n    {\n        *pT = (*pT)->Right;\n        return;\n    }\n\n    if ((*pT)->Left == NULL)\n    {\n        *pT = (*pT)->Left;\n        return;\n    }\n\n    (*pT)->Key = deleteMax(&((*pT)->Left));\n}\n")),(0,o.kt)("h2",{id:"rightsibling"},"rightSibling"),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"T\xecm ki\u1ebfm n\xfat anh em ru\u1ed9t ph\u1ea3i c\u1ee7a n\xfat c\xf3 kh\xf3a x trong c\xe2y t\xecm ki\u1ebfm nh\u1ecb ph\xe2n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c"},"Tree rightSibling(int x, Tree root)\n{\n    if (root == NULL || root->Left == NULL)\n        return NULL;\n\n    if (root->Left->Key == x)\n        return root->Right;\n\n    if (x < root->Key)\n        return rightSibling(x, root->Left);\n    return rightSibling(x, root->Right);\n}\n")),(0,o.kt)("h2",{id:"printpath"},"printPath"),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"H\xe0m li\u1ec7t k\xea (in) c\xe1c gi\xe1 tr\u1ecb kh\xf3a tr\xean \u0111\u01b0\u1eddng \u0111i c\u1ee7a vi\u1ec7c t\xecm ki\u1ebfm m\u1ed9t kh\xf3a x trong c\xe2y t\xecm ki\u1ebfm nh\u1ecb ph\xe2n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c"},'void printPath(int x, Tree root)\n{\n    if (root == NULL)\n    {\n        printf("-> Khong thay");\n        return;\n    }\n    printf("%d ", root->Key);\n    if (root->Key == x)\n    {\n        printf("-> Tim thay");\n        return;\n    }\n    if (x < root->Key)\n        return printPath(x, root->Left);\n    return printPath(x, root->Right);\n}\n')),(0,o.kt)("h2",{id:"getparent"},"getParent"),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"H\xe0m t\xecm ki\u1ebfm n\xfat cha c\u1ee7a n\xfat c\xf3 kh\xf3a x trong c\xe2y t\xecm ki\u1ebfm nh\u1ecb ph\xe2n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c"},"Tree getParent(int x, Tree root)\n{\n    if (root == NULL)\n        return NULL;\n\n    if (x < root->Key)\n    {\n        if (root->Left == NULL)\n            return NULL;\n        if (root->Left->Key == x)\n            return root;\n        return getParent(x, root->Left);\n    }\n\n    if (root->Right == NULL)\n        return NULL;\n    if (root->Right->Key == x)\n        return root;\n    return getParent(x, root->Right);\n}\n")),(0,o.kt)("h2",{id:"insertnode"},"insertNode"),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"Th\xeam kh\xf3a X v\xe0o c\xe2y t\xecm ki\u1ebfm nh\u1ecb ph\xe2n ch\u1ec9 b\u1edfi con tr\u1ecf pT")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c"},"void insertNode(int x, Tree *pRoot)\n{\n    if (*pRoot == NULL)\n    {\n        (*pRoot) = (Tree)malloc(sizeof(struct Node));\n        (*pRoot)->Left = NULL;\n        (*pRoot)->Right = NULL;\n        (*pRoot)->Key = x;\n        return;\n    }\n    if (x == (*pRoot)->Key)\n        return;\n    if (x < (*pRoot)->Key)\n        return insertNode(x, &((*pRoot)->Left));\n\n    return insertNode(x, &((*pRoot)->Right));\n}\n")),(0,o.kt)("h2",{id:"searchnode"},"searchNode"),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"H\xe0m t\xecm ki\u1ebfm kh\xf3a x trong c\xe2y t\xecm ki\u1ebfm nh\u1ecb ph\xe2n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c"},"Tree searchNode(int x, Tree root)\n{\n    if (root == NULL)\n        return NULL;\n    if (x < root->Key)\n        return searchNode(x, root->Left);\n    if (x > root->Key)\n        return searchNode(x, root->Right);\n    return root;\n}\n")),(0,o.kt)("h2",{id:"hnode"},"hNode"),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"H\xe0m t\xednh chi\u1ec1u cao c\u1ee7a n\xfat c\xf3 kh\xf3a x trong c\xe2y T")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c"},"int getHeight(Tree T)\n{\n    if (T == NULL)\n        return -1;\n    int lh = getHeight(T->Left);\n    int rh = getHeight(T->Right);\n\n    return 1 + (lh > rh ? lh : rh);\n}\n\nint hNode(int x, Tree root)\n{\n    if (root == NULL)\n        return getHeight(root);\n\n    if (root->Key == x)\n        return getHeight(root);\n\n    if (x < root->Key)\n        return hNode(x, root->Left);\n    return hNode(x, root->Right);\n}\n")),(0,o.kt)("h2",{id:"getprevious"},"getPrevious"),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"H\xe0m tr\u1ea3 v\u1ec1 con tr\u1ecf c\u1ee7a n\xfat \u0111\u1ee9ng tr\u01b0\u1edbc n\xfat c\xf3 kh\xf3a x cho tr\u01b0\u1edbc trong ph\xe9p duy\u1ec7t trung t\u1ef1 (gi\u1ea3 s\u1eed x ch\u1eafc ch\u1eafn c\xf3 trong c\xe2y T)")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c"},"Tree leftest(Tree root)\n{\n    if (root == NULL)\n        return NULL;\n    if (root->Left == NULL)\n        return root;\n    return leftest(root->Left);\n}\nTree rightest(Tree root)\n{\n    if (root == NULL)\n        return NULL;\n\n    if (root->Right == NULL)\n        return root;\n    return rightest(root->Right);\n}\n\nTree getPrevious(int x, Tree root)\n{\n    if (root == NULL)\n        return NULL;\n    if (root->Key == x)\n        if (root->Left != NULL)\n            return rightest(root->Left);\n\n    Tree lrest = leftest(root->Right);\n\n    if (lrest != NULL)\n        if (lrest->Key == x)\n            return root;\n\n    if (x < root->Key)\n        return getPrevious(x, root->Left);\n    return getPrevious(x, root->Right);\n}\n")))}d.isMDXComponent=!0}}]);