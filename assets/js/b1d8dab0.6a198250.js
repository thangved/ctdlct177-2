"use strict";(self.webpackChunkctdlct_177_2=self.webpackChunkctdlct_177_2||[]).push([[7876],{3905:(n,t,e)=>{e.d(t,{Zo:()=>l,kt:()=>c});var i=e(7294);function L(n,t,e){return t in n?Object.defineProperty(n,t,{value:e,enumerable:!0,configurable:!0,writable:!0}):n[t]=e,n}function s(n,t){var e=Object.keys(n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(n,t).enumerable}))),e.push.apply(e,i)}return e}function r(n){for(var t=1;t<arguments.length;t++){var e=null!=arguments[t]?arguments[t]:{};t%2?s(Object(e),!0).forEach((function(t){L(n,t,e[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(e)):s(Object(e)).forEach((function(t){Object.defineProperty(n,t,Object.getOwnPropertyDescriptor(e,t))}))}return n}function o(n,t){if(null==n)return{};var e,i,L=function(n,t){if(null==n)return{};var e,i,L={},s=Object.keys(n);for(i=0;i<s.length;i++)e=s[i],t.indexOf(e)>=0||(L[e]=n[e]);return L}(n,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(n);for(i=0;i<s.length;i++)e=s[i],t.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(n,e)&&(L[e]=n[e])}return L}var a=i.createContext({}),p=function(n){var t=i.useContext(a),e=t;return n&&(e="function"==typeof n?n(t):r(r({},t),n)),e},l=function(n){var t=p(n.components);return i.createElement(a.Provider,{value:t},n.children)},d={inlineCode:"code",wrapper:function(n){var t=n.children;return i.createElement(i.Fragment,{},t)}},P=i.forwardRef((function(n,t){var e=n.components,L=n.mdxType,s=n.originalType,a=n.parentName,l=o(n,["components","mdxType","originalType","parentName"]),P=p(e),c=L,u=P["".concat(a,".").concat(c)]||P[c]||d[c]||s;return e?i.createElement(u,r(r({ref:t},l),{},{components:e})):i.createElement(u,r({ref:t},l))}));function c(n,t){var e=arguments,L=t&&t.mdxType;if("string"==typeof n||L){var s=e.length,r=new Array(s);r[0]=P;var o={};for(var a in t)hasOwnProperty.call(t,a)&&(o[a]=t[a]);o.originalType=n,o.mdxType="string"==typeof n?n:L,r[1]=o;for(var p=2;p<s;p++)r[p]=e[p];return i.createElement.apply(null,r)}return i.createElement.apply(null,e)}P.displayName="MDXCreateElement"},7923:(n,t,e)=>{e.r(t),e.d(t,{assets:()=>a,contentTitle:()=>r,default:()=>d,frontMatter:()=>s,metadata:()=>o,toc:()=>p});var i=e(7462),L=(e(7294),e(3905));const s={},r="Th\u01b0 vi\u1ec7n danh s\xe1ch li\xean k\u1ebft (PListLib.c)",o={unversionedId:"adts-pointerlist/PListLib",id:"adts-pointerlist/PListLib",title:"Th\u01b0 vi\u1ec7n danh s\xe1ch li\xean k\u1ebft (PListLib.c)",description:"T\u1ea3i v\u1ec1 t\u1ea1i \u0111\xe2y",source:"@site/docs/adts-pointerlist/PListLib.md",sourceDirName:"adts-pointerlist",slug:"/adts-pointerlist/PListLib",permalink:"/docs/adts-pointerlist/PListLib",draft:!1,editUrl:"https://github.com/thangved/datastructure/docs/adts-pointerlist/PListLib.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Danh s\xe1ch sinh vi\xean",permalink:"/docs/adts-pointerlist/student-define"},next:{title:"T\u1ed5ng quan",permalink:"/docs/adts-stack/intro"}},a={},p=[],l={toc:p};function d(n){let{components:t,...s}=n;return(0,L.kt)("wrapper",(0,i.Z)({},l,s,{components:t,mdxType:"MDXLayout"}),(0,L.kt)("h1",{id:"th\u01b0-vi\u1ec7n-danh-s\xe1ch-li\xean-k\u1ebft-plistlibc"},"Th\u01b0 vi\u1ec7n danh s\xe1ch li\xean k\u1ebft (PListLib.c)"),(0,L.kt)("p",null,(0,L.kt)("a",{target:"_blank",href:e(3322).Z},"T\u1ea3i v\u1ec1 t\u1ea1i \u0111\xe2y")),(0,L.kt)("pre",null,(0,L.kt)("code",{parentName:"pre",className:"language-c"},'/**\n * @file PListLib.c\n * @author Kim Minh Th\u1eafng (https://github.com/thangved)\n * @brief Th\u01b0 vi\u1ec7n danh s\xe1ch li\xean k\u1ebft\n * @version 0.1\n * @date 2021-09-03\n *\n * @copyright Copyright (c) 2021\n *\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n\n/*__DEFINE__TYPE__*/\ntypedef int ElementType; // kieu cua phan tu du lieu\n\nstruct Node\n{\n    ElementType Element;\n    struct Node *Next;\n};\n\ntypedef struct Node *Position; // kieu vi tri\ntypedef Position List;\n/*__END__DEFINE__TYPE__*/\n\n/*__FUNCTION__DECLARATION__*/\nvoid deleteList(Position P, List *pL);                // xoa phan tu sau vi tri P\nint emptyList(List L);                                //  kiem tra danh sach co rong hay khong\nPosition first(List L);                               // tra ve vi tri dau tien\nPosition endList(List L);                             // tra ve vi tri phan tu cuoi cung\nvoid insertList(ElementType X, Position P, List *pL); // chen them mot phan tu\nPosition locate(ElementType x, List L);               // tra ve vi tri phan tu dau tien co gia tri X\nPosition myLocate(ElementType x, int i, List L);      // tra ve phan tu x thu i\nvoid makenullList(List *pL);                          // khoi tao danh sach rong\nPosition next(Position P, List L);                    // tra ve vi tri tiep theo\nPosition previous(Position P, List L);                // tra ve vi tri truoc P\nElementType retrieve(Position P, List L);             // tra ve gia tri phan tu\n/*__END__FUNCTION__DECLARATION__*/\n\n/*__FUNCTION__*/\nvoid deleteList(Position P, List *pL)\n{\n    Position Temp;\n    if (P->Next != NULL)\n    {\n        Temp = P->Next;\n        P->Next = Temp->Next;\n        free(Temp);\n    }\n}\nint emptyList(List L)\n{\n    return L->Next == NULL;\n}\nPosition endList(List L)\n{\n    Position P = L;\n    while (1)\n    {\n        if (P->Next == NULL)\n            return P;\n        P = P->Next;\n    }\n}\nPosition first(List L)\n{\n    return L;\n}\nvoid insertList(ElementType x, Position P, List *pL)\n{\n    Position T;\n    T = (Position)malloc(sizeof(struct Node));\n    T->Element = x;\n    T->Next = P->Next;\n    P->Next = T;\n}\nPosition locate(ElementType x, List L)\n{\n    Position P = L;\n    while (P->Next != NULL)\n    {\n        if (P->Next->Element == x)\n            return P;\n        P = P->Next;\n    }\n    return P;\n}\nvoid makenullList(List *pL)\n{\n    *pL = (List)malloc(sizeof(struct Node));\n    (*pL)->Next = NULL;\n}\nPosition myLocate(ElementType x, int i, List L)\n{\n    Position P = L;\n    int count = 0;\n    while (P->Next != NULL)\n    {\n        if (P->Next->Element == x)\n            count++;\n        if (count == i)\n            return P->Next;\n        P = P->Next;\n    }\n    return P->Next;\n}\nPosition next(Position P, List L)\n{\n    return P->Next;\n}\nPosition previous(Position P, List L)\n{\n    Position Q = L;\n    while (Q->Next->Next != NULL)\n    {\n        if (Q->Next->Next == P)\n            Q = Q->Next;\n    }\n    return Q->Next;\n}\nElementType retrieve(Position P, List L)\n{\n    if (P->Next != NULL)\n        return P->Next->Element;\n}\n/*__END__FUNCTION__*/\n#define USE_ALL 1\n#ifdef USE_ALL\n/*__OTHER__FUNCTION__*/\n/*__DECLARATION__*/\nvoid addFirst(ElementType x, List *pL);  // them phan tu vao vi tri dau tien\nvoid append(ElementType x, List *pL);    // them phan tu vao cuoi ds\nvoid copyEvenNumbers(List L, List *pL);  // sao chep so le tu L qua pL\nvoid deleteX(ElementType x, List *pL);   // xoa phan tu x\nList difference(List L1, List L2);       // tra ve tap hieu cua L1 L2\nvoid erase(ElementType x, List *pL);     // xoa phan tu x dau tien\nfloat getAvg(List L);                    // tra ve trung binh cong\nList intersection(List L1, List L2);     // tra ve tap giao cua L1 L2\nint member(ElementType x, List L);       // kiem tra phan tu co trong L\nvoid normalize(List *pL);                // bien danh sach thanh tap hop\nvoid printList(List L);                  // hien thi danh sach phan tu\nvoid printOddNumbers(List L);            // in so le\nList readSet();                          // nhap tap hop\nvoid removeAll(ElementType x, List *pL); // xoa tat ca phan tu x\nvoid readList(List *pL);                 // nhap danh sach tu ban phim\nvoid sort(List *pL);                     // sap xep danh sach\nList unionSet(List L1, List L2);         // tinh tap hop cua 2 ds\n/*__END__DECLARATION__*/\n\n/*__FUNCTION__BODY__*/\nvoid addFirst(ElementType x, List *pL)\n{\n    insertList(x, first(*pL), pL);\n}\nvoid append(ElementType x, List *pL)\n{\n    if (!member(x, *pL))\n        insertList(x, endList(*pL), pL);\n}\nvoid copyEvenNumbers(List L, List *pL)\n{\n    makenullList(pL);\n    Position P = first(L);\n    Position End = endList(L);\n    while (P != End)\n    {\n        if (retrieve(P, L) % 2 == 0)\n            append(retrieve(P, L), pL);\n        else\n            P = next(P, L);\n    }\n}\nvoid deleteX(ElementType x, List *pL)\n{\n    while (locate(x, *pL) != endList(*pL))\n    {\n        deleteList(locate(x, *pL), pL);\n    }\n}\nList difference(List L1, List L2)\n{\n    List L;\n    Position P = first(L1);\n    Position EL1 = endList(L1);\n    Position EL2 = endList(L2);\n    while (P != EL1)\n    {\n        if (locate(retrieve(P, L1), L2) != EL2)\n            append(retrieve(P, L1), &L);\n        P = next(P, L1);\n    }\n}\nvoid erase(ElementType x, List *pL)\n{\n    if (locate(x, *pL) != endList(*pL))\n        deleteList(locate(x, *pL), pL);\n}\nfloat getAvg(List L)\n{\n    float sum = 0;\n    int length = 0;\n    Position P = first(L);\n    Position E = endList(L);\n    while (P != E)\n    {\n        sum += retrieve(P, L);\n        P = next(P, L);\n        length++;\n    }\n    return sum / length;\n}\nList intersection(List L1, List L2)\n{\n    List L;\n    makenullList(&L);\n    Position P2 = first(L2);\n    Position E2 = endList(L2);\n    while (P2 != E2)\n    {\n        if (member(retrieve(P2, L2), L1))\n            if (!member(retrieve(P2, L2), L))\n                addFirst(retrieve(P2, L2), &L);\n        P2 = next(P2, L2);\n    }\n    return L;\n}\nint member(ElementType x, List L)\n{\n    return locate(x, L) != endList(L);\n}\nvoid normalize(List *pL)\n{\n    Position P = *pL, Q;\n    while (P->Next != NULL)\n    {\n        Q = P->Next;\n        while (Q->Next != NULL)\n        {\n            if (P->Next->Element == Q->Next->Element)\n            {\n                deleteList(Q, pL);\n            }\n            else\n            {\n                Q = Q->Next;\n            }\n        }\n        P = P->Next;\n    }\n}\nvoid printList(List L)\n{\n    Position P = first(L);\n    Position E = endList(L);\n    while (P != E)\n    {\n        printf("%d ", retrieve(P, L));\n        P = next(P, L);\n    }\n    printf("\\n");\n}\nvoid printOddNumbers(List L)\n{\n    Position P = L;\n    while (P->Next != NULL)\n    {\n        if (P->Next->Element % 2 != 0)\n            printf("%d ", P->Next->Element);\n        P = P->Next;\n    }\n    printf("\\n");\n}\nList readSet()\n{\n    List L;\n    makenullList(&L);\n    int n;\n    ElementType e;\n    scanf("%d", &n);\n    for (int i = 0; i < n; i++)\n    {\n        scanf("%d", &e);\n        if (member(e, L))\n            continue;\n        addFirst(e, &L);\n    }\n\n    return L;\n}\nvoid removeAll(ElementType x, List *pL)\n{\n    while (locate(x, *pL)->Next != NULL)\n        deleteList(locate(x, *pL), pL);\n}\nvoid readList(List *pL)\n{\n    makenullList(pL);\n    int n;\n    scanf("%d", &n);\n    ElementType e;\n    for (int i = 0; i < n; i++)\n    {\n        scanf("%d", &e);\n        insertList(e, endList(*pL), pL);\n    }\n}\nvoid sort(List *pL)\n{\n    Position P = *pL,\n             N;\n    while (P->Next != NULL)\n    {\n        N = P->Next;\n        while (N->Next != NULL)\n        {\n            if (P->Next->Element > N->Next->Element)\n            {\n                ElementType Temp = P->Next->Element;\n                P->Next->Element = N->Next->Element;\n                N->Next->Element = Temp;\n            }\n            N = N->Next;\n        }\n        P = P->Next;\n    }\n}\nList unionSet(List L1, List L2)\n{\n    List L;\n    makenullList(&L);\n    Position P1 = first(L1),\n             P2 = first(L2),\n             E1 = endList(L1),\n             E2 = endList(L2);\n    while (P1 != E1)\n    {\n        insertList(retrieve(P1, L1), endList(L), &L);\n        P1 = next(P1, L1);\n    }\n\n    while (P2 != E2)\n    {\n        if (!member(retrieve(P2, L2), L))\n            insertList(retrieve(P2, L2), endList(L), &L);\n        P2 = next(P2, L2);\n    }\n\n    return L;\n}\n/*__END__FUNCTION__BODY__*/\n/*__END__OTHER__FUNCTION__*/\n#endif\n')))}d.isMDXComponent=!0},3322:(n,t,e)=>{e.d(t,{Z:()=>i});const i=e.p+"assets/files/PListLib-9d40a6ce122ceb615cffbf1ab2728804.c"}}]);